# 野火F103MINI板

安装各种芯片包，才能使用对应的芯片进行调试（KEIL5）

## DAP仿真器下载程序

### 仿真器配置

1、Debug的选配

2、Utilities的选配

3、Debug Settings的选配

### 选目标板

### 下载程序

Application running ...

## 串口下载程序（使用相对于的软件）

使用的是hex文件或者bin文件来进行烧录程序

## STM32

其中分为软件部分和硬件部分

软件部分使用的是keil5软件、VS2019、vcode等等，多学习c语言的编程知识，主要的是逻辑思维，多看不断积累，不断学习

硬件部分使用的是AD软件，来进行原理图的设计，分析电源部分，产生的各种问题，如出现辐射现象，要考虑节约成本，多方面考虑问题，不断积累，很吃经验。经验告诉自己固定这样做。并且进行PCB的布局之类的，建议看哔哩哔哩中的凡亿教育的课程，多学习AD软件的快捷键。

## 寄存器

### 芯片

芯片包括M3内核和外设连接构成

### 存储器映射

4GB的地址空间 = 8 * 512 MB = 8 * 512 * 1024 * 1024 Bytes = 4294967296 Bytes

4294967296（十进制）= 0x100000000（十六进制）地址范围：0x00000000~0xFFFFFFFF

平分为8个地址

536870912（十进制） = 0x20000000（十六进制）地址范围：0x00000000~0x1FFFFFFF

1个字节 = 1 Byte = 8 Bits

1 KB = 1024 Bytes（表示1024个地址，1024（十进制） = 0x400（十六进制）地址范围：0x00~0x3FF）

1 MB = 1024 KB

1 GB = 1024 MB

Block0主要用于设计片内的FLASH，0x08000000~0x0807FFFF(512KB)

Block1用于设计片内的SRAM，0x20000000~0x2000FFFF（64KB）

### 寄存器映射

1个单元 = 4个字节 = 32 bits

eg：

​	GPIOB端口输出数据寄存器ODR的地址是 0x40010C0C，ODR寄存器是32bit，低16bit有效，对应16个外部IO

```c
// GPIOB 端口全部输出 高电平
*(unsigned int*)(0x4001 0C0C) = 0xFFFF;
```

0x4001 0C0C 在我们看来是GPIOB 端口ODR 的地址，但是在编译器看来，这只是一个普通的变量，是一个立即数，要想让编译器也认为是指针，我们得进行强制类型转换，把它转换成指针，即(unsigned int *)0x4001 0C0C，然后再对这个指针进行 * 操作。

```c
// GPIOB 端口全部输出 高电平
#define GPIOB_ODR *(unsigned int*)(GPIOB_BASE+0x0C)
GPIOB_ODR = 0xFF;
```

#### STM32外设地址映射

片上外设分为三条总线，APB1挂载低速外设，APB2和AHB挂载高速外设。

##### 总线基地址

| 总线名称 | 总线基地址  | 相对外设基地址的偏移 |
| -------- | ----------- | -------------------- |
| APB1     | 0x4000 0000 | 0x0                  |
| APB2     | 0x4001 0000 | 0x0001 0000          |
| AHB      | 0x4001 8000 | 0x0001 8000          |

##### 外设基地址

GPIO这个外设属于高速的外设，挂载到APB2总线上。

| 外设名称 | 外设基地址  | 相对APB2总线的地址偏移 |
| -------- | ----------- | ---------------------- |
| GPIOA    | 0x4001 0800 | 0x0000 0800            |
| GPIOB    | 0x4001 0C00 | 0x0000 0C00            |
| GPIOC    | 0x4001 1000 | 0x0000 1000            |
| GPIOD    | 0x4001 1400 | 0x0000 1400            |
| GPIOE    | 0x4001 1800 | 0x0000 1800            |
| GPIOF    | 0x4001 1C00 | 0x0000 1C00            |
| GPIOG    | 0x4001 2000 | 0x0000 2000            |

##### 外设寄存器

| 寄存器名称 | 寄存器地址  | 相对GPIO基址的偏移 |
| ---------- | ----------- | ------------------ |
| GPIOB_CRL  | 0x4001 0C00 | 0x00               |
| GPIOB_CRH  | 0x4001 0C04 | 0x04               |
| GPIOB_IDR  | 0x4001 0C08 | 0x08               |
| GPIOB_ODR  | 0x4001 0C0C | 0x0C               |
| GPIOB_BSRR | 0x4001 0C10 | 0x10               |
| GPIOB_BRR  | 0x4001 0C14 | 0x14               |
| GPIOB_LCKR | 0x4001 0C18 | 0x18               |

每一个寄存器都有16个引脚，分为三种状态：w、r、w\r，并包括设置或者清除位。eg：BR0写入“1”代表第0引脚输出“低电平”，但是写入“0”不会影响0位，BS0写入“1”代表引脚输出“高电平”。

#### 修改寄存器的位操作

##### 将变量的某位清零

```c
//定义一个变量a = 1001 1111 b (二进制数)
unsigned char a = 0x9f;

//对bit2 清零

a &= ~(1<<2);

//括号中的1 左移两位，(1<<2)得二进制数：0000 0100 b
//按位取反，~(1<<2)得1111 1011 b
//假如a 中原来的值为二进制数： a = 1001 1111 b
//所得的数与a 作”位与&”运算，a = (1001 1111 b)&(1111 1011 b),
//经过运算后，a 的值 a=1001 1011 b
//a的bit2位被清零，而其他位不变。
```

##### 将变量的某几个连续位清零

```c
//若把a 中的二进制位分成2 个一组
//即bit0、bit1 为第0 组，bit2、bit3 为第1 组，
// bit4、bit5 为第2 组，bit6、bit7 为第3 组
//要对第1 组的bit2、bit3 清零

a &= ~(3<<2*1);

//括号中的3 左移两位，(3<<2*1)得二进制数：0000 1100 b
//按位取反，~(3<<2*1)得1111 0011 b
//假如a 中原来的值为二进制数： a = 1001 1111 b
//所得的数与a 作”位与&”运算，a = (1001 1111 b)&(1111 0011 b),
//经过运算后，a 的值 a=1001 0011 b
// a 的第1 组的bit2、bit3 被清零，而其它位不变。

//上述(~(3<<2*1))中的(1)即为组编号;如清零第3 组bit6、bit7 此处应为3
//括号中的(2)为每组的位数，每组有2 个二进制位;若分成4 个一组，此处即为4
//括号中的(3)是组内所有位都为1 时的值;若分成4 个一组，此处即为二进制数“1111 b”

//例如对第2 组bit4、bit5 清零
a &= ~(3<<2*2);
```

##### 将变量的某几位进行赋值

```c
//a = 1000 0011 b
//此时对清零后的第2 组bit4、bit5 设置成二进制数“01 b ”

a |= (1<<2*2);
//a = 1001 0011 b，成功设置了第2 组的值，其它组不变
```

##### 将变量的某位取反

```c
//a = 1001 0011 b
//把bit6 取反，其它位不变

a ^=(1<<6);
//a = 1101 0011 b
```

## 新建工程---寄存器版

### 新建工程

#### 新建本地工程文件夹

为了工程目录更加清晰，我们在本地电脑上新建1 个文件夹用于存放整个工程，如命名为“LED”，然后在该目录下新建2 个文件夹

| 名称                  | 作用                                                |
| --------------------- | --------------------------------------------------- |
| Listing               | 存放编译器编译时候产生的c/汇编/链接的列表清单       |
| Output（或者Objects） | 存放编译产生的调试信息、hex文件、预览信息、封装库等 |

| 名称                  | 作用                                                |
| --------------------- | --------------------------------------------------- |
| LED                   | 存放startup_stm32f10x_hd.s、stm32f10x.h、main.c文件 |
| Listing               | 暂时为空                                            |
| Output（或者Objects） | 暂时为空                                            |

#### 新建工程

打开KEIL5，新建---Project---New Project...

选择CPU型号

添加文件---startup_stm32f10x_hd.s、stm32f10x.h、main.c

配置魔术棒选项卡---47页

下载器配置

### 下载程序

点击LOAD按钮

## 寄存器点亮LED灯

### GPIO

GPIOA到FPIOE共5组，每组16个引脚，具有输入输出功能

输入功能是检测外部输入电平，通过电平高低区分按键是否被按下

输出功能是高低电平的输出切换，实现开关控制，来控制灯的亮灭

#### 基本结构

![1](https://github.com/Leon199601/MCU/blob/main/pic/w-1.jpg)

##### 1、保护二极管及上、下拉电阻

当引脚电压高于Vdd时，上方二极管导通

当引脚电压小于Vss时，下方二极管导通，防止不正常电压引入芯片导致芯片烧毁，保护芯片。

如果直接驱动电机，必须加大功率及隔离电路驱动。

##### 2、P-MOS和N-MOS管

输出控制部分：该结构使得GPIO具有“推挽输出”和“开漏输出”

推挽输出，是根据两个MOS管的工作方式来命名。

输入高点平时，上方P-MOS导通，下方N-MOS关闭，对外输出高电平，高电平为3.3伏；

输入低点平时，下方N-MOS导通，上方P-MOS关闭，对外输出低电平，低电平为0伏；

推挽输出一般应用在输出电平为0和3.3伏而且需要高速切换开关状态的场合。STM32应用中，除了必须用开楼模式的场合，都习惯用推挽输出模式。

![2](https://github.com/Leon199601/MCU/blob/main/pic/w-2.jpg)

开漏输出，上方的P-MOS管完全不工作。

如果控制输出为0，低电平，则P-MOS管关闭，N-MOS管导通，输出接地；

如控制输出为1，则P-MOS和N-MOS都关闭，引脚既不输出高电平，也不输出低电平，为高阻态。正常使用必须外部接上拉电阻，等效电路，具有“线与”特性，也就是说，若有很多个开漏输出引脚连接在一起，只有当所有的引脚为高阻态，才由上拉电阻提供高电平，此高电平的电压为外部上拉电阻所接的电源的电压。若其中一个引脚为低电平，那线路相当于短路接地，整条线路都是低电平，0伏。

![3](https://github.com/Leon199601/MCU/blob/main/pic/w-3.jpg)

开漏输出一般应用在I2C、SMBUS通讯等需要“线与”功能的总线电路中。

除此之外，还用在电平不匹配的场合，如需要5伏的高电平，就可以外部接一个上拉电阻，上拉电源为5伏，GPIO设置为开漏模式，当输出高阻态时，由上拉电阻和电源向外输出5伏的电平。

![4](https://github.com/Leon199601/MCU/blob/main/pic/w-4.jpg)

##### 3、输出数据寄存器GPIOx_ODR

双MOS管结构电路的输入信号，是由GPIO“输出数据寄存器GPIOx_ODR"来控制，

“置位/复位寄存器GPIOx_BSRR"可以修改输出数据寄存器的值。

##### 4、复用功能输出

“复用”是指STM32的其他片上外设对GPIO引脚进行控制，从其他外设引出的“复用功能输出信号”与GPIO的数据寄存器，通过梯形结构作为开关切换选择。

例如：使用USART串口通讯时，需要用到某个GPIO引脚作为通讯发送引脚，这时候就可以把该GPIO引脚配置为USART串口复用功能，由串口外设控制该引脚，发送数据。

```c
//GPIOB  16个IO全部输出  0XFF
GPIOB-> = 0XFF;
```

##### 5、输入数据寄存器GPIOx_IDR

GPIO引脚经过内部的上、下拉电阻，可配置成上/下拉输入，再连接施密特触发器，信号经过触发器，模拟信号转化为0、1数字信号，存储在“输入数据寄存器GPIOx_IDR"，读取寄存器就可以了解GPIO引脚的电平状态。

```c
//读取GPIOB端口的16位数据值
uint16_t temp;
temp = GPIOB->IDR;
```

##### 6、复用功能输入

与复用功能输出类似，GPIO引脚的信号传输到STM32其他片上外设，由该外设读取引脚状态。

例如：使用USART串口通讯时，需要用到某个GPIO引脚作为通讯接收引脚，这时候就可以把该GPIO引脚配置为USART串口复用功能，由串口外设控制该引脚，接收数据。

##### 7、模拟输入输出

当GPIO 引脚用于ADC 采集电压的输入通道时，用作“模拟输入”功能，此时信号是不经过施密特触发器的，因为经过施密特触发器后信号只有0、1 两种状态，所以ADC 外设要采集到原始的模拟信号，信号源输入必须在施密特触发器之前。

类似地，当GPIO 引脚用于DAC 作为模拟电压输出通道时，此时作为“模拟输出”功能，DAC 的模拟信号输出就不经过双MOS 管结构，模拟信号直接输出到引脚。

#### GPIO工作模式

```c
//GPIOG 8种工作模式
typedef enum
{
	GPIO_Mode_AIN = 0x0,			//模拟输入
	GPIO_Mode_IN_FLOATING = 0x04,	//浮空输入
	GPIO_Mode_IPD = 0x28,			//下拉输入
	GPIO_Mode_IPU = 0x48,			//上拉输入
	GPIO_Mode_Out_OD = 0x14,		//开漏输出
	GPIO_Mode_Out_PP = 0x10,		//推挽输出
	GPIO_Mode_AF_OD = 0x1C,			//复用开漏输出
	GPIO_Mode_AF_PP = 0x18			//复用推挽输出
} GPIOMode_TypeDef;
```

8种工作模式大致分为三类：

##### 1、输入模式（模拟/浮空/上拉/下拉）

在输入模式时，施密特触发器打开，输出被禁止，可通过输入数据寄存器GPIOx_IDR读取I/O 状态。

输入模式，可设置为上拉、下拉、浮空和模拟输入四种。

上拉和下拉输入很好理解，默认的电平由上拉或者下拉决定。

浮空输入的电平是不确定的，完全由外部的输入决定，一般接按键的时候用的是这个模式。

模拟输入则用于ADC 采集。

##### 2、输出模式（推挽/开漏）

在输出模式中，推挽模式时双MOS 管以轮流方式工作，输出数据寄存器GPIOx_ODR可控制I/O 输出高低电平。开漏模式时，只有N-MOS 管工作，输出数据寄存器可控制I/O输出高阻态或低电平。输出速度可配置，有2MHz\10MHz\50MHz 的选项。此处的输出速度即I/O 支持的高低电平状态最高切换频率，支持的频率越高，功耗越大，如果功耗要求不严格，把速度设置成最大即可。
在输出模式时施密特触发器是打开的，即输入可用，通过输入数据寄存器GPIOx_IDR可读取I/O 的实际状态。

##### 3、复用功能（推挽/开漏）

复用功能模式中，输出使能，输出速度可配置，可工作在开漏及推挽模式，但是输出信号源于其它外设，输出数据寄存器GPIOx_ODR 无效；输入可用，通过输入数据寄存器可获取I/O 实际状态，但一般直接用外设的寄存器来获取该数据信号。
通过对GPIO 寄存器写入不同的参数，就可以改变GPIO 的工作模式，再强调一下，要了解具体寄存器时一定要查阅==《STM32F10X-中文参考手册》==中对应外设的寄存器说明。
在GPIO 外设中，控制端口高低控制寄存器CRH 和CRL 可以配置每个GPIO 的工作模式和工作的速度，每4 个位控制一个IO，CRH 控制端口的高八位，CRL 控制端口的低8 位，具体的看CRH 和CRL 的寄存器描述。

![5](https://github.com/Leon199601/MCU/blob/main/pic/w-5.jpg)

![6](https://github.com/Leon199601/MCU/blob/main/pic/w-6.jpg)

### 实验：使用寄存器点亮LED灯

先了解原理，打开“8-使用寄存器点亮LED灯”文件---打开“.uvprojx”，可看见三个文件，startup_stm32f10x_hd.s 、stm32f10x.h 以及main.c

#### 1、硬件连接

目标是把GPIO的引脚设置为推挽输出模式并且默认下拉，输出低电平，这样LED灯亮起了。

![7](https://github.com/Leon199601/MCU/blob/main/pic/w-7.jpg)

#### 2、启动文件

startup_stm32f10x_hd.s 文件里使用的是汇编语言，，当STM32 芯片上电启动的时候，首先会执行这里的汇编程序，从而建立起C 语言的运行环境，所以我们把这个文件称为启动文件。该文件使用的汇编指令是Cortex-M3 内核支持的指令，可参考==《Cortex-M3 权威指南》==中指令集章节。
startup_stm32f10x_hd.s 文件由官方提供，一般有需要也是在官方的基础上修改，不会自己完全重写。该文件从 ST 固件库里面找到，找到该文件后把启动文件添加到工程里面即可。不同型号的芯片以及不同编译环境下使用的汇编文件是不一样的，但功能相同。

总结启动文件的功能，如下：

初始化堆栈指针SP

初始化程序计数器指针PC

设置堆、栈的大小

初始化中断向量表

配置外部SRAM作为数据存储器（这个由用户配置，一般的开发板可没有外部SRAM）

调用SystemIni()函数配置STM32的系统时钟

设置C库的分支入口“__main”(最终用来调用main函数)

主要理解最后两点，在启动文件中有一段复位后立即执行的程序，见下代码。在实际工程中阅读时，可使用编辑器的搜索(Ctrl+F)功能查找这段代码在文件中的位置，搜索Reset_Handler 即可找到。

```assembly
;复位后执行的程序
; Reset handler
Reset_Handler   PROC
                EXPORT  Reset_Handler             [WEAK]
                IMPORT  __main
                IMPORT  SystemInit
                LDR     R0, =SystemInit
                BLX     R0               
                LDR     R0, =__main
                BX      R0
                ENDP
```

第一二行是程序注释，汇编里注释“；”，类似C语言“//”注释符

第三行定义子程序：Reset_Handler，PROC是子程序定义伪指令。相当于C语言中定义一个函数，函数名为Reset_Handler。

第四行EXPORT表示Reset_Handler这个子程序可供其他模块调用。相当于C语言函数声明。关键字[WEAK]表示弱定义，如果编译器发现在别处定义了同名的函数，则在链接时用别处的地址进行链接，如果其它地方没有定义，编译器也不报错，以此处地址进行链接。

第五六行IMPORT说明 SystemInit 和__main 这两个标号在其他文件，在链接的时候需要到其他文件去寻找。相当于C 语言中，从其它文件引入函数声明。以便下面对外部函数进行调用。

SystemInit 需要由我们自己实现，即我们要编写一个具有该名称的函数，用来初始化STM32 芯片的时钟，一般包括初始化AHB、APB 等各总线的时钟，需要经过一系列的配置STM32 才能达到稳定运行的状态。其实这个函数在固件库里面有提供，官方已经为我们写好。

__main 其实不是我们定义的(不要与C 语言中的main 函数混淆)，这是一个C 库函数，当编译器编译时，只要遇到这个标号就会定义这个函数，该函数的主要功能是：负责初始化栈、堆，配置系统环境，并在函数的最后调用用户编写的 main 函数，从此来到 C 的世界。

第七行把SystemInit 的地址加载到寄存器 R0。

第八行程序跳转到 R0 中的地址执行程序，即执行SystemInit 函数的内容。

第九行把__main的地址加载到寄存器R0。

第十行行程序跳转到 R0 中的地址执行程序，即执行__main 函数，执行完毕之后就去到我们熟知的 C 世界，进入main 函数。
第十行表示子程序的结束。
总之，看完这段代码后，了解到如下内容即可：

1.我们需要在外部定义一个SystemInit函数设置STM32 的时钟；

2.STM32 上电后，会执行SystemInit 函数，最后执行我们C 语言中的main 函数。

#### 3、stm32f10x.h文件

连接LED灯的GPIO引脚，通过读写寄存器来控制，寄存器映射就是给一个已经分配好地址的特殊的内存空间取的一个别名，这个特殊的内存空间就是寄存器，它可以通过指针来操作。在编程之前我们要先实现寄存器映射，寄存器映射的代码都统一写在stm32f10x.h 文件中

```c
/*片上外设基地址  */
#define PERIPH_BASE           ((unsigned int)0x40000000)

/*APB2 总线基地址 */
#define APB2PERIPH_BASE       (PERIPH_BASE + 0x10000)
/* AHB总线基地址 */
#define AHBPERIPH_BASE        (PERIPH_BASE + 0x20000)

/*GPIOC外设基地址*/
#define GPIOC_BASE            (APB2PERIPH_BASE + 0x1000)

/* GPIOC寄存器地址,强制转换成指针 */
#define GPIOC_CRL			*(unsigned int*)(GPIOC_BASE+0x00)
#define GPIOC_CRH			*(unsigned int*)(GPIOC_BASE+0x04)
#define GPIOC_IDR			*(unsigned int*)(GPIOC_BASE+0x08)
#define GPIOC_ODR			*(unsigned int*)(GPIOC_BASE+0x0C)
#define GPIOC_BSRR	  *(unsigned int*)(GPIOC_BASE+0x10)
#define GPIOC_BRR			*(unsigned int*)(GPIOC_BASE+0x14)
#define GPIOC_LCKR		*(unsigned int*)(GPIOC_BASE+0x18)

/*RCC外设基地址*/
#define RCC_BASE      (AHBPERIPH_BASE + 0x1000)
/*RCC的AHB1时钟使能寄存器地址,强制转换成指针*/
#define RCC_APB2ENR		 *(unsigned int*)(RCC_BASE+0x18)
```

最后两段是RCC 外设寄存器的地址定义，RCC 外设是用来设置时钟的，以后我们会详细分析，本实验中只要了解到使用GPIO 外设必须开启它的时钟即可。

#### 4、main文件

先编写main函数

```c
int main (void)
{
}
```

此时直接编译报错：

“Error: L6218E: Undefined symbol SystemInit (referred from startup_stm32f10x.o)”

错误提示SystemInit 没有定义。

从分析启动文件时我们知道，Reset_Handler 调用了该函数用来初始化SMT32 系统时钟，为了简单起见，我们在 main 文件里面定义一个SystemInit 空函数，什么也不做，为的是骗过编译器，把这个错误去掉。关于配置系统时钟我们在后面再写。当我们不配置系统时钟时，STM32 会把HSI 当作系统时钟，HSI=8M，由芯片内部的振荡器提供。我们在main 中添加如下函数：

```c
// 函数为空，目的是为了骗过编译器不报错
void SystemInit(void)
{	
}
```

或者还有一种方法（不建议使用此方法）：在启动文件中把有关SystemInit 的代码注释掉

```assembly
; Reset handler
Reset_Handler   PROC
                EXPORT  Reset_Handler             [WEAK]
                IMPORT  __main
                
                ;IMPORT  SystemInit
                ;LDR     R0, =SystemInit
                ;BLX     R0
                
                LDR     R0, =__main
                BX      R0
                ENDP
```

开启点灯之旅，在main函数中添加代码

##### 1.GPIO模式

设置GPIO引脚配置为输出模式，即配置GPIO的端口配置低寄存器CRL,CRL包含0-7号引脚，每个引脚占用4个寄存器。MODE 位用来配置输出的速度，CNF 位用来配置各种输入输出模式。在这里我们把GPIO 引脚配置为通用推挽输出，输出的速度为10M

```c
//清空控制PC2的端口位
GPIOC_CRL &= ~( 0x0F<< (4*2));	
// 配置PC2为通用推挽输出，速度为10M
GPIOC_CRL |= (1<<4*2);
```

![8](https://github.com/Leon199601/MCU/blob/main/pic/w-8.jpg)

在代码中，我们先把控制PC2 的端口位清0，然后再向它赋值“0001 b”，从而使GPIOC2 引脚设置成输出模式，速度为10M。
代码中使用了“&=~”、“|=”这种操作方法是为了避免影响到寄存器中的其它位。因为寄存器不能按位读写，假如我们直接给CRL 寄存器赋值： GPIOC_CRL = 0x0000 0100;这时CRL 的的低8~11 位被设置成“0001”输出模式，但其它GPIO 引脚就有意见了，因为其它引脚的MODER 位都已被设置成输入模式(即全部被清0)。所以，为了在配置寄存器某个位的时候不影响其它位，推荐使用 “ &=~ ”和“ |= ”这两种操作方式，其中“ &=~ ”用于清0，“ |= ”用于置1

##### 2.控制引脚输出电平

输出模式，对端口位设置/清除寄存器BSRR 寄存器、端口位清除寄存器BRR 和ODR 寄存器写入参数即可控制引脚的电平状态，其中操作BSRR 和BRR 最终影响的都是ODR 寄存器，然后再通过ODR 寄存器的输出来控制GPIO。为了一步到位，我们在这里直接操作ODR 寄存器来控制GPIO 的电平

```c
// PC2 输出 低电平
GPIOC_ODR &= ~(1<<2);
```

![9](https://github.com/Leon199601/MCU/blob/main/pic/w-9.jpg)

##### 3.开启外设时钟

STM32 的 外设很多，为了降低功耗，每个外设都对应着一个时钟，在芯片刚上电的时候这些时钟都是被关闭的，如果想要外设工作，必须把相应的时钟打开。
STM32 的所有外设的时钟由一个专门的外设来管理，叫 RCC（reset and clockcontrol），RCC 在==《 STM32 中文参考手册》==的第六章。关于RCC 外设中的时钟部分，我们在后面的章节《RCC—使用HSE/HIS 配置》中有详细的讲解，这里我们暂时先了解下。所有的 GPIO 都挂载到 APB2 总线上，具体的时钟由APB2 外设时钟使能寄存器(RCC_APB2ENR)来控制

```c
// 开启GPIOC 端口时钟
RCC_APB2ENR |= (1<<4);
```

![10](https://github.com/Leon199601/MCU/blob/main/pic/w-10.jpg)

##### 4.成功点亮，水到渠成

开启时钟，配置引脚模式，控制电平，控制一个LED灯。

```c
int main(void)
{	
	// 开启GPIOC 端口时钟
	RCC_APB2ENR |= (1<<4);

	//清空控制PC2的端口位
	GPIOC_CRL &= ~( 0x0F<< (4*2));	
	// 配置PC2为通用推挽输出，速度为10M
	GPIOC_CRL |= (1<<4*2);

	// PC2 输出 低电平
	GPIOC_ODR &= ~(1<<2);
	
	while(1);
}
```

## 构建库函数雏形

为了更好的维护，要学习STM32的固件库，在固件库的基础上了解底层，学习寄存器。

### STM32函数库

固件库就是指“STM32标准函数库”，由ST公司针对STM32提供的函数接口（API），开发者调用这些函数接口来配置STM32的寄存器。开发快速、易阅读、维护成本低

![11](https://github.com/Leon199601/MCU/blob/main/pic/w-11.jpg)

### 用库来开发及学习

采用直接配置寄存器的方式开发的程序员，会列举以下原因：
(1) 具体参数更直观
(2) 程序运行占用资源少

相对于库开发的方式，直接配置寄存器方式生成的代码量的确会少一点，但因为STM32 有充足的资源，权衡库的优势与不足，绝大部分时候，我们愿意牺牲一点CPU 资源，选择库开发。一般只有在对代码运行时间要求极苛刻的地方，才用直接配置寄存器的方式代替，如频繁调用的中断服务函数。

对于库开发与直接配置寄存器的方式，就好比编程是用汇编好还是用 C 好一样。在STM32F1 系列刚推出函数库时引起程序员的激烈争论，但是，随着ST 库的完善与大家对库的了解，更多的程序员选择了库开发。现在STM32F1 系列和STM32F4 系列各有一套自己的函数库，但是它们大部分是兼容的，F1 和F4 之间的程序移植，只需要小修改即可。而如果要移植用寄存器写的程序，那简直跟脱胎换骨差不多。

用库来进行开发，市场已有定论，用户群说明了一切，但对于STM32 的学习仍然有人认为用寄存器好，而且汇编不是还没退出大学教材么？认为这种方法直观，能够了解到是配置了哪些寄存器，怎样配置寄存器。事实上，库函数的底层实现恰恰是直接配置寄存器方式的最佳例子，它代替我们完成了寄存器配置的工作，而想深入了解芯片是如何工作的话，只要直接查看库函数的最底层实现就能理解，相信你会为它严谨、优美的实现方式而陶醉，要==想修炼C 语言，就从ST 的库开始==吧。所以在以后的章节中，使用软件库是我们的重点，而且我们通过讲解库API 去效地学习STM32 的寄存器，并不至于因为用库学习，就不会用寄存器控制STM32 芯片。

### 实验：构建库函数雏形

在寄存器点亮LED的代码上完善，把代码一层层封装，实现库的最初的雏形，打开配套例程“9-自己写库—构建库函数雏形”来理解阅读

#### 1、外设寄存器结构体定义

