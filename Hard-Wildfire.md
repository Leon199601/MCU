# 野火F103MINI板

安装各种芯片包，才能使用对应的芯片进行调试（KEIL5）

## DAP仿真器下载程序

### 仿真器配置

1、Debug的选配

2、Utilities的选配

3、Debug Settings的选配

### 选目标板

### 下载程序

Application running ...

## 串口下载程序（使用相对于的软件）

使用的是hex文件或者bin文件来进行烧录程序

## STM32

其中分为软件部分和硬件部分

软件部分使用的是keil5软件、VS2019、vcode等等，多学习c语言的编程知识，主要的是逻辑思维，多看不断积累，不断学习

硬件部分使用的是AD软件，来进行原理图的设计，分析电源部分，产生的各种问题，如出现辐射现象，要考虑节约成本，多方面考虑问题，不断积累，很吃经验。经验告诉自己固定这样做。并且进行PCB的布局之类的，建议看哔哩哔哩中的凡亿教育的课程，多学习AD软件的快捷键。

## 寄存器

### 芯片

芯片包括M3内核和外设连接构成

### 存储器映射

4GB的地址空间 = 8 * 512 MB = 8 * 512 * 1024 * 1024 Bytes = 4294967296 Bytes

4294967296（十进制）= 0x100000000（十六进制）地址范围：0x00000000~0xFFFFFFFF

平分为8个地址

536870912（十进制） = 0x20000000（十六进制）地址范围：0x00000000~0x1FFFFFFF

1个字节 = 1 Byte = 8 Bits

1 KB = 1024 Bytes（表示1024个地址，1024（十进制） = 0x400（十六进制）地址范围：0x00~0x3FF）

1 MB = 1024 KB

1 GB = 1024 MB

Block0主要用于设计片内的FLASH，0x08000000~0x0807FFFF(512KB)

Block1用于设计片内的SRAM，0x20000000~0x2000FFFF（64KB）

### 寄存器映射

1个单元 = 4个字节 = 32 bits

eg：

​	GPIOB端口输出数据寄存器ODR的地址是 0x40010C0C，ODR寄存器是32bit，低16bit有效，对应16个外部IO

```c
// GPIOB 端口全部输出 高电平
*(unsigned int*)(0x4001 0C0C) = 0xFFFF;
```

0x4001 0C0C 在我们看来是GPIOB 端口ODR 的地址，但是在编译器看来，这只是一个普通的变量，是一个立即数，要想让编译器也认为是指针，我们得进行强制类型转换，把它转换成指针，即(unsigned int *)0x4001 0C0C，然后再对这个指针进行 * 操作。

```c
// GPIOB 端口全部输出 高电平
#define GPIOB_ODR *(unsigned int*)(GPIOB_BASE+0x0C)
GPIOB_ODR = 0xFF;
```

#### STM32外设地址映射

片上外设分为三条总线，APB1挂载低速外设，APB2和AHB挂载高速外设。

##### 总线基地址

| 总线名称 | 总线基地址  | 相对外设基地址的偏移 |
| -------- | ----------- | -------------------- |
| APB1     | 0x4000 0000 | 0x0                  |
| APB2     | 0x4001 0000 | 0x0001 0000          |
| AHB      | 0x4001 8000 | 0x0001 8000          |

##### 外设基地址

GPIO这个外设属于高速的外设，挂载到APB2总线上。

| 外设名称 | 外设基地址  | 相对APB2总线的地址偏移 |
| -------- | ----------- | ---------------------- |
| GPIOA    | 0x4001 0800 | 0x0000 0800            |
| GPIOB    | 0x4001 0C00 | 0x0000 0C00            |
| GPIOC    | 0x4001 1000 | 0x0000 1000            |
| GPIOD    | 0x4001 1400 | 0x0000 1400            |
| GPIOE    | 0x4001 1800 | 0x0000 1800            |
| GPIOF    | 0x4001 1C00 | 0x0000 1C00            |
| GPIOG    | 0x4001 2000 | 0x0000 2000            |

##### 外设寄存器

| 寄存器名称 | 寄存器地址  | 相对GPIO基址的偏移 |
| ---------- | ----------- | ------------------ |
| GPIOB_CRL  | 0x4001 0C00 | 0x00               |
| GPIOB_CRH  | 0x4001 0C04 | 0x04               |
| GPIOB_IDR  | 0x4001 0C08 | 0x08               |
| GPIOB_ODR  | 0x4001 0C0C | 0x0C               |
| GPIOB_BSRR | 0x4001 0C10 | 0x10               |
| GPIOB_BRR  | 0x4001 0C14 | 0x14               |
| GPIOB_LCKR | 0x4001 0C18 | 0x18               |

每一个寄存器都有16个引脚，分为三种状态：w、r、w\r，并包括设置或者清除位。eg：BR0写入“1”代表第0引脚输出“低电平”，但是写入“0”不会影响0位，BS0写入“1”代表引脚输出“高电平”。

#### 修改寄存器的位操作

##### 将变量的某位清零

```c
//定义一个变量a = 1001 1111 b (二进制数)
unsigned char a = 0x9f;

//对bit2 清零

a &= ~(1<<2);

//括号中的1 左移两位，(1<<2)得二进制数：0000 0100 b
//按位取反，~(1<<2)得1111 1011 b
//假如a 中原来的值为二进制数： a = 1001 1111 b
//所得的数与a 作”位与&”运算，a = (1001 1111 b)&(1111 1011 b),
//经过运算后，a 的值 a=1001 1011 b
//a的bit2位被清零，而其他位不变。
```

##### 将变量的某几个连续位清零

```c
//若把a 中的二进制位分成2 个一组
//即bit0、bit1 为第0 组，bit2、bit3 为第1 组，
// bit4、bit5 为第2 组，bit6、bit7 为第3 组
//要对第1 组的bit2、bit3 清零

a &= ~(3<<2*1);

//括号中的3 左移两位，(3<<2*1)得二进制数：0000 1100 b
//按位取反，~(3<<2*1)得1111 0011 b
//假如a 中原来的值为二进制数： a = 1001 1111 b
//所得的数与a 作”位与&”运算，a = (1001 1111 b)&(1111 0011 b),
//经过运算后，a 的值 a=1001 0011 b
// a 的第1 组的bit2、bit3 被清零，而其它位不变。

//上述(~(3<<2*1))中的(1)即为组编号;如清零第3 组bit6、bit7 此处应为3
//括号中的(2)为每组的位数，每组有2 个二进制位;若分成4 个一组，此处即为4
//括号中的(3)是组内所有位都为1 时的值;若分成4 个一组，此处即为二进制数“1111 b”

//例如对第2 组bit4、bit5 清零
a &= ~(3<<2*2);
```

##### 将变量的某几位进行赋值

```c
//a = 1000 0011 b
//此时对清零后的第2 组bit4、bit5 设置成二进制数“01 b ”

a |= (1<<2*2);
//a = 1001 0011 b，成功设置了第2 组的值，其它组不变
```

##### 将变量的某位取反

```c
//a = 1001 0011 b
//把bit6 取反，其它位不变

a ^=(1<<6);
//a = 1101 0011 b
```

## 新建工程---寄存器版

### 新建工程

#### 新建本地工程文件夹

为了工程目录更加清晰，我们在本地电脑上新建1 个文件夹用于存放整个工程，如命名为“LED”，然后在该目录下新建2 个文件夹

| 名称                  | 作用                                                |
| --------------------- | --------------------------------------------------- |
| Listing               | 存放编译器编译时候产生的c/汇编/链接的列表清单       |
| Output（或者Objects） | 存放编译产生的调试信息、hex文件、预览信息、封装库等 |

| 名称                  | 作用                                                |
| --------------------- | --------------------------------------------------- |
| LED                   | 存放startup_stm32f10x_hd.s、stm32f10x.h、main.c文件 |
| Listing               | 暂时为空                                            |
| Output（或者Objects） | 暂时为空                                            |

#### 新建工程

打开KEIL5，新建---Project---New Project...

选择CPU型号

添加文件---startup_stm32f10x_hd.s、stm32f10x.h、main.c

配置魔术棒选项卡---47页

下载器配置

### 下载程序

点击LOAD按钮

## 寄存器点亮LED灯

### GPIO

GPIOA到FPIOE共5组，每组16个引脚，具有输入输出功能

输入功能是检测外部输入电平，通过电平高低区分按键是否被按下

输出功能是高低电平的输出切换，实现开关控制，来控制灯的亮灭

#### 基本结构

![1](https://github.com/Leon199601/MCU/blob/main/pic/w-1.jpg)

##### 1、保护二极管及上、下拉电阻

当引脚电压高于Vdd时，上方二极管导通

当引脚电压小于Vss时，下方二极管导通，防止不正常电压引入芯片导致芯片烧毁，保护芯片。

如果直接驱动电机，必须加大功率及隔离电路驱动。

##### 2、P-MOS和N-MOS管

输出控制部分：该结构使得GPIO具有“推挽输出”和“开漏输出”

推挽输出，是根据两个MOS管的工作方式来命名。

输入高点平时，上方P-MOS导通，下方N-MOS关闭，对外输出高电平，高电平为3.3伏；

输入低点平时，下方N-MOS导通，上方P-MOS关闭，对外输出低电平，低电平为0伏；

推挽输出一般应用在输出电平为0和3.3伏而且需要高速切换开关状态的场合。STM32应用中，除了必须用开楼模式的场合，都习惯用推挽输出模式。

![2](https://github.com/Leon199601/MCU/blob/main/pic/w-2.jpg)

开漏输出，上方的P-MOS管完全不工作。

如果控制输出为0，低电平，则P-MOS管关闭，N-MOS管导通，输出接地；

如控制输出为1，则P-MOS和N-MOS都关闭，引脚既不输出高电平，也不输出低电平，为高阻态。正常使用必须外部接上拉电阻，等效电路，具有“线与”特性，也就是说，若有很多个开漏输出引脚连接在一起，只有当所有的引脚为高阻态，才由上拉电阻提供高电平，此高电平的电压为外部上拉电阻所接的电源的电压。若其中一个引脚为低电平，那线路相当于短路接地，整条线路都是低电平，0伏。

![3](https://github.com/Leon199601/MCU/blob/main/pic/w-3.jpg)

开漏输出一般应用在I2C、SMBUS通讯等需要“线与”功能的总线电路中。

除此之外，还用在电平不匹配的场合，如需要5伏的高电平，就可以外部接一个上拉电阻，上拉电源为5伏，GPIO设置为开漏模式，当输出高阻态时，由上拉电阻和电源向外输出5伏的电平。

![4](https://github.com/Leon199601/MCU/blob/main/pic/w-4.jpg)

##### 3、输出数据寄存器GPIOx_ODR

双MOS管结构电路的输入信号，是由GPIO“输出数据寄存器GPIOx_ODR"来控制，

“置位/复位寄存器GPIOx_BSRR"可以修改输出数据寄存器的值。

##### 4、复用功能输出

“复用”是指STM32的其他片上外设对GPIO引脚进行控制，从其他外设引出的“复用功能输出信号”与GPIO的数据寄存器，通过梯形结构作为开关切换选择。

例如：使用USART串口通讯时，需要用到某个GPIO引脚作为通讯发送引脚，这时候就可以把该GPIO引脚配置为USART串口复用功能，由串口外设控制该引脚，发送数据。

```c
//GPIOB  16个IO全部输出  0XFF
GPIOB-> = 0XFF;
```

##### 5、输入数据寄存器GPIOx_IDR

GPIO引脚经过内部的上、下拉电阻，可配置成上/下拉输入，再连接施密特触发器，信号经过触发器，模拟信号转化为0、1数字信号，存储在“输入数据寄存器GPIOx_IDR"，读取寄存器就可以了解GPIO引脚的电平状态。

```c
//读取GPIOB端口的16位数据值
uint16_t temp;
temp = GPIOB->IDR;
```

##### 6、复用功能输入

与复用功能输出类似，GPIO引脚的信号传输到STM32其他片上外设，由该外设读取引脚状态。

例如：使用USART串口通讯时，需要用到某个GPIO引脚作为通讯接收引脚，这时候就可以把该GPIO引脚配置为USART串口复用功能，由串口外设控制该引脚，接收数据。

##### 7、模拟输入输出

当GPIO 引脚用于ADC 采集电压的输入通道时，用作“模拟输入”功能，此时信号是不经过施密特触发器的，因为经过施密特触发器后信号只有0、1 两种状态，所以ADC 外设要采集到原始的模拟信号，信号源输入必须在施密特触发器之前。

类似地，当GPIO 引脚用于DAC 作为模拟电压输出通道时，此时作为“模拟输出”功能，DAC 的模拟信号输出就不经过双MOS 管结构，模拟信号直接输出到引脚。

#### GPIO工作模式

```c
GPIOG 8种工作模式
typedef enum
{
	GPIO_Mode_AIN = 0x0，			//模拟输入
	GPIO_Mode_IN_FLOATING = 0x04，	//浮空输入
	GPIO_Mode_IPD = 0x28，			//下拉输入
	GPIO_Mode_IPU = 0x48，			//上拉输入
	GPIO_Mode_Out_OD = 0x14，		//开漏输出
	GPIO_Mode_Out_PP = 0x10，		//推挽输出
	GPIO_Mode_AF_OD = 0x1C，			//复用开漏输出
	GPIO_Mode_AF_PP = 0x18			 //复用推挽输出
} GPIOMode_TypeDef;
```

8种工作模式大致分为三类：

##### 1、输入模式（模拟/浮空/上拉/下拉）

在输入模式时，施密特触发器打开，输出被禁止，可通过输入数据寄存器GPIOx_IDR读取I/O 状态。

输入模式，可设置为上拉、下拉、浮空和模拟输入四种。

上拉和下拉输入很好理解，默认的电平由上拉或者下拉决定。

浮空输入的电平是不确定的，完全由外部的输入决定，一般接按键的时候用的是这个模式。

模拟输入则用于ADC 采集。

##### 2、输出模式（推挽/开漏）

在输出模式中，推挽模式时双MOS 管以轮流方式工作，输出数据寄存器GPIOx_ODR可控制I/O 输出高低电平。开漏模式时，只有N-MOS 管工作，输出数据寄存器可控制I/O输出高阻态或低电平。输出速度可配置，有2MHz\10MHz\50MHz 的选项。此处的输出速度即I/O 支持的高低电平状态最高切换频率，支持的频率越高，功耗越大，如果功耗要求不严格，把速度设置成最大即可。
在输出模式时施密特触发器是打开的，即输入可用，通过输入数据寄存器GPIOx_IDR可读取I/O 的实际状态。

##### 3、复用功能（推挽/开漏）

复用功能模式中，输出使能，输出速度可配置，可工作在开漏及推挽模式，但是输出信号源于其它外设，输出数据寄存器GPIOx_ODR 无效；输入可用，通过输入数据寄存器可获取I/O 实际状态，但一般直接用外设的寄存器来获取该数据信号。
通过对GPIO 寄存器写入不同的参数，就可以改变GPIO 的工作模式，再强调一下，要了解具体寄存器时一定要查阅==《STM32F10X-中文参考手册》==中对应外设的寄存器说明。
在GPIO 外设中，控制端口高低控制寄存器CRH 和CRL 可以配置每个GPIO 的工作模式和工作的速度，每4 个位控制一个IO，CRH 控制端口的高八位，CRL 控制端口的低8 位，具体的看CRH 和CRL 的寄存器描述。

![5](https://github.com/Leon199601/MCU/blob/main/pic/w-5.jpg)

![6](https://github.com/Leon199601/MCU/blob/main/pic/w-6.jpg)

### 实验：使用寄存器点亮LED灯

先了解原理，打开“8-使用寄存器点亮LED灯”文件---打开“.uvprojx”，可看见三个文件，startup_stm32f10x_hd.s 、stm32f10x.h 以及main.c

#### 1、硬件连接

目标是把GPIO的引脚设置为推挽输出模式并且默认下拉，输出低电平，这样LED灯亮起了。

![7](https://github.com/Leon199601/MCU/blob/main/pic/w-7.jpg)

#### 2、启动文件

startup_stm32f10x_hd.s 文件里使用的是汇编语言，，当STM32 芯片上电启动的时候，首先会执行这里的汇编程序，从而建立起C 语言的运行环境，所以我们把这个文件称为启动文件。该文件使用的汇编指令是Cortex-M3 内核支持的指令，可参考==《Cortex-M3 权威指南》==中指令集章节。
startup_stm32f10x_hd.s 文件由官方提供，一般有需要也是在官方的基础上修改，不会自己完全重写。该文件从 ST 固件库里面找到，找到该文件后把启动文件添加到工程里面即可。不同型号的芯片以及不同编译环境下使用的汇编文件是不一样的，但功能相同。

总结启动文件的功能，如下：

初始化堆栈指针SP

初始化程序计数器指针PC

设置堆、栈的大小

初始化中断向量表

配置外部SRAM作为数据存储器（这个由用户配置，一般的开发板可没有外部SRAM）

调用SystemIni()函数配置STM32的系统时钟

设置C库的分支入口“__main”(最终用来调用main函数)

主要理解最后两点，在启动文件中有一段复位后立即执行的程序，见下代码。在实际工程中阅读时，可使用编辑器的搜索(Ctrl+F)功能查找这段代码在文件中的位置，搜索Reset_Handler 即可找到。

```assembly
;复位后执行的程序
; Reset handler
Reset_Handler   PROC
                EXPORT  Reset_Handler             [WEAK]
                IMPORT  __main
                IMPORT  SystemInit
                LDR     R0, =SystemInit
                BLX     R0               
                LDR     R0, =__main
                BX      R0
                ENDP
```

第一二行是程序注释，汇编里注释“；”，类似C语言“//”注释符

第三行定义子程序：Reset_Handler，PROC是子程序定义伪指令。相当于C语言中定义一个函数，函数名为Reset_Handler。

第四行EXPORT表示Reset_Handler这个子程序可供其他模块调用。相当于C语言函数声明。关键字[WEAK]表示弱定义，如果编译器发现在别处定义了同名的函数，则在链接时用别处的地址进行链接，如果其它地方没有定义，编译器也不报错，以此处地址进行链接。

第五六行IMPORT说明 SystemInit 和__main 这两个标号在其他文件，在链接的时候需要到其他文件去寻找。相当于C 语言中，从其它文件引入函数声明。以便下面对外部函数进行调用。

SystemInit 需要由我们自己实现，即我们要编写一个具有该名称的函数，用来初始化STM32 芯片的时钟，一般包括初始化AHB、APB 等各总线的时钟，需要经过一系列的配置STM32 才能达到稳定运行的状态。其实这个函数在固件库里面有提供，官方已经为我们写好。

__main 其实不是我们定义的(不要与C 语言中的main 函数混淆)，这是一个C 库函数，当编译器编译时，只要遇到这个标号就会定义这个函数，该函数的主要功能是：负责初始化栈、堆，配置系统环境，并在函数的最后调用用户编写的 main 函数，从此来到 C 的世界。

第七行把SystemInit 的地址加载到寄存器 R0。

第八行程序跳转到 R0 中的地址执行程序，即执行SystemInit 函数的内容。

第九行把__main的地址加载到寄存器R0。

第十行行程序跳转到 R0 中的地址执行程序，即执行__main 函数，执行完毕之后就去到我们熟知的 C 世界，进入main 函数。
第十行表示子程序的结束。
总之，看完这段代码后，了解到如下内容即可：

1、我们需要在外部定义一个SystemInit函数设置STM32 的时钟；

2、STM32 上电后，会执行SystemInit 函数，最后执行我们C 语言中的main 函数。

#### 3、stm32f10x.h文件
